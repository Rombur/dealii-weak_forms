# Weak forms for deal.II
------------------------
An implementation of a symbolic weak form interface for `deal.II`, using 
expression templates as well as automatic and symbolic differentiation. 

Author: Jean-Paul Pelteret, 2020 - 2022

# Table of Contents

- [Concept](#concept)
- [Features](#features)
   - [Highlights](#highlights)
   - [Wishlist and work in progress](#wishlist-and-work-in-progress)
- [Class documentation](#class-documentation)
- [Examples](#examples)
- [Benchmarks](#benchmarks)
- [Building the library](#building-the-library)
- [Similar projects that inspired this work](#similar-projects-that-inspired-this-work)
- [Acknowledgements](#acknowledgements)
- [Contributing](#contributing)
- [License](#license)

# Concept
---------
The idea for this library is to offer an abstraction for the discretisation
of finite element weak forms using the `deal.II` open source finite element
library. It, effectively, allows one to express the assembly of discretised
linear system by the weak form alone, the components of which can be reused
as they are lazily evaluated.

Details as to exactly what the abstraction level is, and how it differs to the
"native" functionality that is already provided in `deal.II` can be found
[here](doc/readme/concept.md).


# Features
----------

## Highlights
- Easy to read and interpret expression of weak forms
- Output of forms in ASCII and LaTeX formats
- Any and all quantities can be retained as intermediate calculations
- Wrappers for many of the commonly used `deal.II` functions and classes
- Operator and function overloading for many `deal.II` dense linear algebra
  classes
- Support for scalar, vector and tensor-valued finite elements
- Support for multi-field forms, thereby supporting the implementation of 
  (coupled) multi-physics problems
- The use of `std::function`s as input to user-definable class value definitions
- Self-linearising forms with specified parameterisations that leverage
  automatic and symbolic differentiation frameworks. This allows for problems
  to be implemented as a (scalar) energy functional or the expression of
  residuals alone. The AD/SD frameworks permit efficient derivative computations
  derived from provided quantities.
- Volume, boundary and interface integration
  - Assembly loops, assembling cell or face matrix and/or vector contributions
    into a global linear system
  - Summation of quantities (like the integral of a field value)
- Supports MPI and serial computing concepts
- Automatically implements multi-threading along with `SIMD` vectorisation
  (when available)

## Wishlist and work in progress
- Currently only supports non-hp finite element methods, but
  [hp-FEM support is imminent](https://github.com/dealii/dealii/pull/13181)
- The datatype for calculations (`float`, `double`, `std::complex<...>`) is,
  chosen only at assembly time and is in principle, generic. 
  This feature, however, needs to be tested more thoroughly.
- Performance improvements for the self-linearising forms is an ongoing area of
  interest and research. 
- A matrix-free implementation will be investigated in the future.
- Python bindings, to be usable in Jupyter Notebooks, will be investigated.

# Class documentation
---------------------
Some documentation for the user-interactive classes and some details
of how they can be used are found [here](doc/readme/classes.md).


# Examples
----------
Some examples and output can be found [here](doc/readme/examples.md).


# Benchmarks
------------
The results of some preliminary benchmarks can be found [here](doc/readme/benchmarks.md).

To summarise, for matrix-based methods the convenience that might be found in
using such a library does come at some overhead. The overheads may be mitigated
when higher order finite element methods are used (i.e. when using higher order 
FEs, a "typical" hand-written assembly loop (meaning, the canonical approach used
in the `deal.II` tutorials) *may* be evaluated slower than the assembly loop 
generated by this library and when all the appropriate settings permitting
optimisations have been chosen). However, there are many factors that might
influence the performance of a code so this comment, guided by the observations
made in the (limited) benchmarking study, should not be considered general truth.
It might be prudent to conduct some examinations of your own before accepting
the analysis done here and following any guidance given by the author.


# Building the library
----------------------
This library requires `deal.II` version `10.0.0` (at the time of writing, this
means the developer version), and at the moment requires that `deal.II` is built
with the following dependencies:
-  ADOL-C
-  Trilinos (with Sacado)
-  SymEngine

Since interaction with these libraries is actually optional, at some point in 
the future these requirements will be removed.

This project uses `CMake` as a build generator. The code block below encapsulates
the various options that can be passed on `CMake` to configure the project before
compilation.

```bash
cmake \
-DCMAKE_BUILD_TYPE=[Debug/Release] \
-DCMAKE_INSTALL_PREFIX=<path_to_installation_location> \
-BUILD_BENCHMARKS=[ON/OFF] \
-DBUILD_DOCUMENTATION=[ON/OFF] \
-DBUILD_TESTS=[ON/OFF] \
-DDEAL_II_DIR=<path> \
-DDEAL_II_SOURCE_DIR=<path> \ # Only required when tests or benchmarks are enabled
-DDOXYGEN_EXECUTABLE=<path_to_doxygen> \ # Only required when documentation is built
-DCLANGFORMAT=[ON/OFF] \
-DCLANGFORMAT_EXECUTABLE=<path_to_clang-format> \ # Only required when code formatting is quired
<path_to_weak_forms_source>
```

To date, this library has only been built and tested on `MacOS` with the `Clang`
compiler. In the future, the `GCC` compiler and the `Linux` operating system will
be tested as well.

## Dependency recommentations
-----------------------------
- If you plan on using multi-threading and the `SD` framework provided by one of
  the self-linearising functors, then SymEngine (a `deal.II` dependency) should
  be built with the option `-DWITH_SYMENGINE_THREAD_SAFE:BOOL=ON`.


# Similar projects that inspired this work
------------------------------------------
- `deal.II`
  - [CFL form language for deal.II](https://github.com/masterleinad/CFL) by Daniel Arndt and Guido Kanschat
- Other finite element and finite volume codes
  - [FEniCS](https://fenicsproject.org/): [Unified Form Language](https://github.com/FEniCS/ufl)
  - [NGSolve](https://ngsolve.org/): [Symbolic Integrators](https://docu.ngsolve.org/latest/how_to/symbolic_integrators.html)
  - [OpenFOAM](https://openfoam.com/): [Equation representation](https://cfd.direct/openfoam/user-guide/v6-programming-language-openfoam/)
- Other codes that use expression templates
  - [Sacado](https://trilinos.github.io/sacado.html): [Automatic differentiation using operator overloading](https://github.com/trilinos/Trilinos/tree/master/packages/sacado) 


# Acknowledgements
------------------
- The LaTeX output for the various examples was rendered using the [Interactive LaTeX Editor](https://arachnoid.com/latex/).


# Contributing
--------------
Please read the contributing documentation [here](contributing.md).


# License
---------
This project is licensed under the GNU Lesser General Public License v3.0.
For more information, see the `LICENSE.md` and `COPYING.LESSER` files.

    Weak forms for deal.II: An implementation of a symbolic weak form interface
    for deal.II, using expression templates as well as automatic and symbolic
    differentiation. 

    Copyright (C) 2021 - 2022  Jean-Paul Pelteret

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.